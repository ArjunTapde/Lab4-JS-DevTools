1) Since `i` was initialized using `var`, this means that `i` does not have block scope. As a result, even though `i` is initalized within the for loop, it can still be accessed outside of that for loop in the function (function-scope). So, the value of `i` will be printed at Line 11, which is representative of the length of `prices` - 1.
2) Since `discountedPrice` was initalized using `var` within the for loop, this means that `discountedPrice` does not have block scope. As a result, `discountedPrice` can be accessed outside of the for loop within the function. As a result, Line 12 will print the discounted price of the last price element in the `prices` parameter. This value is equal to prices[prices.length - 1] * (1 - discount).
3) Since `finalPrice` is within the scope of Line 13, as they are both under the function `discountPrices`, it's value is able to be printed at Line 13. This value will take the same value as that printed by Line 12, however it will be rounded to the nearest 2 decimal places (i.e. 12.75).
4) If we call `discountPrices([100, 200, 300], .5)`, the function will return the array `discounted` whose value is `[50, 100, 150]`. To explain, the fucntion will traverse through the parameter `prices` array and within the for loop, it will take every element in `prices` and calculate the discounted price and round that discounted price to 2 decimal places. Then, these calculated discounted prices are pushed into a `discounted` array, which will then be returned by the function. Thus, giving us `[50, 100, 150]` for the call `discountPrices([100, 200, 300], .5)`.
5) At Line 11, a reference error will occur because `i` was initialized using `let` in a for loop block. As a result, the scope of `i` is confined to the for loop block and cannot be accessed outside of it. So, at Line 11 the reference error will state that it cannot find the variable `i`.
6) At Line 12, a reference error will occur because `discountedPrice` was initialized using `let` in a for loop block. As a result, the scope of `discountedPrice` is confined to the for loop block and cannot be accessed outside of it. So, at Line 12 the reference error will state that it cannot find the variable `discountedPrice`.
7) At Line 13, the value of finalPrice will be printed, this value will be equal to the last price element in `prices` with the discount and 2-decimal rounding applied to it. This is because finalPrice was initialized using `let` and its scope is the entirity of the function `discountPrices` which means it is accessible at line 13, as line 13 is within the function `discountPrices`.
8) If the scope errors given by lines 11 and 12 are not resolved, the function will not run and nothing would be returned. If the lines (11,12) that are giving scope errors are removed, then the function on the call `discountPrices([100, 200, 300], .5)` will return the array `discounted` whose value would be `[50, 100, 150]`.To explain, the fucntion will traverse through the parameter `prices` array and within the for loop, it will take every element in `prices` and calculate the discounted price and round that discounted price to 2 decimal places. Then, these calculated discounted prices are pushed into a `discounted` array, which will then be returned by the function. Thus, giving us `[50, 100, 150]` for the call `discountPrices([100, 200, 300], .5)`. The array `discounted` will be accessible at Line 14 because `discounted` was intialized using `let` at Line 2, meaning it's scope is the entiriety of the function `discountPrices`, including in the for loop. 
9) At Line 11, a reference error will occur because `i` was initialized using `let` in a for loop block. As a result, the scope of `i` is confined to the for loop block and cannot be accessed outside of it. So, at Line 11 the reference error will state that it cannot find the variable `i`.
10) At Line 12, a reference error will occur because `discountedPrice` was initialized using `const` in a for loop block. As a result, the scope of `discountedPrice` is confined to the for loop block and cannot be accessed outside of it. So, at Line 12 the reference error will state that it cannot find the variable `discountedPrice`. 
11) An error will occur due to `finalPrice` being initialized with `const` and in the for loop, there is a line trying to set this const variable's value to another value. When a variable is initialized with `const`, its value cannot be changed. However in the for loop this being attempted, as a result this will cause a error due to trying to change the value of a `const` variable.
12) On the call `discountPrices([100, 200, 300], .5)` the function will not return any values because an error will occur. This is because `finalPrice` is initialized using `const` to a value of 0, however its value is attempted to be changed in the following for loop. This will cause an error stating that this variable cannot be reassigned, since due to `const` the value of  `finalPrice` is set to 0 and cannot be changed to any other value. A variable initalized with `const` cannot have its value changed. 
13) a) `student.name` b) `student['Grad Year']` c) `student.greeting()` d) `student['Favorite Teacher'].name` e) `student.courseLoad[0]`
14) 
* a) '32'. If the the binary `+` is applied to a string, it concatenates them. If any of the operands is a string, the other one is converted to a string as well. As a result, the 2 is converted to a '2' and is concatenates to the string '3' to result in '32'.
* b) 1. If subtraction is applied and one of the operands is a number, the other operand will be converted to a number as well. Therefore, '3' becomes 3 and is subtracted by 2, which is results in the number 1.
* c) 3. The `+` will perform addition and null will be converted to its number value 0. As a result, the equation is now simple addition 3 + 0 = 3.
* d) '3null'. If the the binary `+` is applied to a string, it concatenates them. If any of the operands is a string, the other one is converted to a string as well. As a result, the null is converted to a 'null' and is concatenates to the string '3' to result in '3null'.
* e) 4. The `+` will perform addition and true will be converted to its boolean number value 1. As a result, the equation is now simple addition 1 + 3 = 4.
* f) 0. The `+` will perform addition and false will be converted to its boolean number value 0 and null will be converted to its number value 0. As a result, the equation is now simple addition 0 + 0 = 0.
* g) '3undefined'. If the the binary `+` is applied to a string, it concatenates them. If any of the operands is a string, the other one is converted to a string as well. As a result, the undefined is converted to a 'undefined' and is concatenates to the string '3' to result in '3undefined'.
* h) NaN. The subtraction will cause both operands to be converted to numerical values. Here "3" would be converted to 3 and undefined does not have a numerical value so this comes out to be NaN. This equation simplifies to 3 - NaN, resulting in a NaN value. 
15)
* a) True. When comparing values of different types, JS will convert the values to numbers. So in this equation the '2' will convert to the integer 2. This equation then becomes 2 > 1, which is a true statment. Therefore, the output is true.
* b) False. In JS when you are comparing strings, you need to use lexographical ordering. In lexographical ordering, '2' is greater than '12' so therefore the statement '2' < '12' is false, as outputted by JS.
* c) True. When comparing values of different types, JS will convert the values to numbers. So in this equation the '2' will convert to the integer 2. This equation then becomes 2 == 2, which is a true statment. Therefore, the output is true.
* d) False. The `===` is a strict equality operator that will check the equality without any type conversion. So, if operands are of different types, then `===` will imediately return false. 2 === '2' are operands of two different types, therefore the statement is false, as returned by JS.
* e) False. When comparing values of different types, JS will convert the values to numbers. So in this equation true will convert to the boolean integer 1. This equation then becomes 1 == 2, which is a false statment. Therefore JS outputs false.
* f) True. The `===` is a strict equality operator that will check the equality without any type conversion. In this case we have `Boolean(2)` which will convert 2 to true. This simplifies the equation to 2 === 2, and since both are integers and the same value this outputs true.
16) The `==` and `===` are two different operators, but both used to check equality. Where `==` does type conversion, `===` does not. `==` will ignore the type of a variable and check if the values are equal, but `===` will check to see if the type and value of both operands are equal. 
17) `How are you?'`. To explain, the code snippet consists of a if, else if, and else block and as a result we must go down this expression and only enter a code block if a condition is met. Let us begin with the first condition, if ( 2 == true). Since a `==` is used, true will be converted to its boolean number value, 1. This equation then becomes 2 == 1, which we know is false, so we do not enter the first code block. Moving to the second condition, if(2). The if() statement is looking to evaluate a boolean value, so since 2 is a non-zero value it is equivalent to true. As a result, we will enter this code block, logging `How are you?`. Since it was a if, else if, else block, we wouldn't evaluate the last else statement as we have found a condition that was true.
18) The answer to this question can be found in the part1 directory in the file part1-question18.js.
19) If the function is called using `modifyArray([1,2,3], doSomething)` the result will be `[6, 8, 10]`. I will now walk through how I got that result. First in the function, we create the empty newArr array. Then we go to a for loop where we push values into the newArr array. Within this push method, we use `callback` which in this case is referencing the `doSomething` function. For this function, we are passing 2 parameters: the array[i] and another callback which is passed in as a function block. What `doSomething` will do is take the array[i], for the first instance this value will be 1, and it will add it by 2, giving us a result of 3. It will return by calling the `callback` function with the new value we just calculated, 3. This function (Line 5) will take the number passed in, 3, and multiply it by 2 and return that value. This gives us 6. As a result, 6 is pushed on to newArr. This continue for the remaining values in the array passed into `modifyArray`. Essentialy this function is taking every number in the array passed in and applying 2(x+2) to that number. After execution, we will be left with `[6, 8, 10]`.
20) The answer to this question can be found in the part1 directory in the file part1-question20.js.
21) The output of the code(including newlines)  
    1  
    4  
    3  
    2
