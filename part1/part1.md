1) Since `i` was initialized using `var`, this means that `i` does not have block scope. As a result, even though `i` is initalized within the for loop, it can still be accessed outside of that for loop in the function (function-scope). So, the value of `i` will be printed at Line 11, which is representative of the length of `prices` - 1.
2) Since `discountedPrice` was initalized using `var` within the for loop, this means that `discountedPrice` does not have block scope. As a result, `discountedPrice` can be accessed outside of the for loop within the function. As a result, Line 12 will print the discounted price of the last price element in the `prices` parameter. This value is equal to prices[prices.length - 1] * (1 - discount).
3) Since `finalPrice` is within the scope of Line 13, as they are both under the function `discountPrices`, it's value is able to be printed at Line 13. This value will take the same value as that printed by Line 12, however it will be rounded to the nearest 2 decimal places (i.e. 12.75).
4) If we call `discountPrices([100, 200, 300], .5)`, the function will return the array `discounted` whose value is `[50, 100, 150]`. To explain, the fucntion will traverse through the parameter `prices` array and within the for loop, it will take every element in `prices` and calculate the discounted price and round that discounted price to 2 decimal places. Then, these calculated discounted prices are pushed into a `discounted` array, which will then be returned by the function. Thus, giving us `[50, 100, 150]` for the call `discountPrices([100, 200, 300], .5)`.
5) At Line 11, a reference error will occur because `i` was initialized using `let` in a for loop block. As a result, the scope of `i` is confined to the for loop block and cannot be accessed outside of it. So, at Line 11 the reference error will state that it cannot find the variable `i`.
6) At Line 12, a reference error will occur because `discountedPrice` was initialized using `let` in a for loop block. As a result, the scope of `discountedPrice` is confined to the for loop block and cannot be accessed outside of it. So, at Line 12 the reference error will state that it cannot find the variable `discountedPrice`.
7) At Line 13, the value of finalPrice will be printed, this value will be equal to the last price element in `prices` with the discount and 2-decimal rounding applied to it. This is because finalPrice was initialized using `let` and its scope is the entirity of the function `discountPrices` which means it is accessible at line 13, as line 13 is within the function `discountPrices`.
8) If the scope errors given by lines 11 and 12 are not resolved, the function will not run and nothing would be returned. If the lines (11,12) that are giving scope errors are removed, then the function on the call `discountPrices([100, 200, 300], .5)` will return the array `discounted` whose value would be `[50, 100, 150]`.To explain, the fucntion will traverse through the parameter `prices` array and within the for loop, it will take every element in `prices` and calculate the discounted price and round that discounted price to 2 decimal places. Then, these calculated discounted prices are pushed into a `discounted` array, which will then be returned by the function. Thus, giving us `[50, 100, 150]` for the call `discountPrices([100, 200, 300], .5)`. The array `discounted` will be accessible at Line 14 because `discounted` was intialized using `let` at Line 2, meaning it's scope is the entiriety of the function `discountPrices`, including in the for loop. 
9) At Line 11, a reference error will occur because `i` was initialized using `let` in a for loop block. As a result, the scope of `i` is confined to the for loop block and cannot be accessed outside of it. So, at Line 11 the reference error will state that it cannot find the variable `i`.
10) At Line 12, a reference error will occur because `discountedPrice` was initialized using `const` in a for loop block. As a result, the scope of `discountedPrice` is confined to the for loop block and cannot be accessed outside of it. So, at Line 12 the reference error will state that it cannot find the variable `discountedPrice`. 
11) An error will occur due to `finalPrice` being initialized with `const` and in the for loop, there is a line trying to set this const variable's value to another value. When a variable is initialized with `const`, its value cannot be changed. However in the for loop this being attempted, as a result this will cause a error due to trying to change the value of a `const` variable.
12) On the call `discountPrices([100, 200, 300], .5)` the function will not return any values because an error will occur. This is because `discounted` and `finalPrice` are both initialized using `const`, however their values are attempted to being changed in the following for loop. This will cause an error stating that this variable cannot be reassigned. 
13) a) `student.name` b) `student['Grad Year']` c) `student.greeting()` d) `student['Favorite Teacher'].name` e) `student.courseLoad[0]`
14) 
* a) '32'. If the the binary `+` is applied to a string, it concatenates them. If any of the operands is a string, the other one is converted to a string as well. As a result, the 2 is converted to a '2' and is concatenates to the string '3' to result in '32'.
* b) 1. If subtraction is applied and one of the operands is a number, the other operand will be converted to a number as well. Therefore, '3' becomes 3 and is subtracted by 2, which is results in the number 1.
* c) 3. The `+` will perform addition and null will be converted to its number value 0. As a result, the equation is now simple addition 3 + 0 = 3.
* d) '3null'. If the the binary `+` is applied to a string, it concatenates them. If any of the operands is a string, the other one is converted to a string as well. As a result, the null is converted to a 'null' and is concatenates to the string '3' to result in '3null'.
* e) 4. The `+` will perform addition and true will be converted to its boolean number value 1. As a result, the equation is now simple addition 1 + 3 = 4.
* f) 0. The `+` will perform addition and false will be converted to its boolean number value 0 and null will be converted to its number value 0. As a result, the equation is now simple addition 0 + 0 = 0.
* g) '3undefined'. If the the binary `+` is applied to a string, it concatenates them. If any of the operands is a string, the other one is converted to a string as well. As a result, the undefined is converted to a 'undefined' and is concatenates to the string '3' to result in '3undefined'.
* h) NaN. The subtraction will cause both operands to be converted to numerical values. Here "3" would be converted to 3 and undefined does not have a numerical value so this comes out to be NaN. This equation simplifies to 3 - NaN, resulting in a NaN value. 
15)
* a) True. When comparing values of different types, JS will convert the values to numbers. So in this equation the '2' will convert to the integer 2. This equation then becomes 2 > 1, which is a true statment. Therefore, the output is true.
* b) False. In JS when you are comparing strings, you need to use lexographical ordering. In lexographical ordering, '2' is greater than '12' so therefore the statement '2' < '12' is false, as outputted by JS.
* c) True. When comparing values of different types, JS will convert the values to numbers. So in this equation the '2' will convert to the integer 2. This equation then becomes 2 == 2, which is a true statment. Therefore, the output is true.
* d) False. The `===` is a strict equality operator that will check the equality without any type conversion. So, if operands are of different types, then `===` will imediately return false. 2 === '2' are operands of two different types, therefore the statement is false, as returned by JS.
* e) False. When comparing values of different types, JS will convert the values to numbers. So in this equation true will convert to the boolean integer 1. This equation then becomes 1 == 2, which is a false statment. Therefore JS outputs false.
* f) True. The `===` is a strict equality operator that will check the equality without any type conversion. In this case we have `Boolean(2)` which will convert 2 to true. This simplifies the equation to 2 === 2, and since both are integers and the same value this outputs true.
16) The `==` and `===` are two different operators, but both used to check equality. Where `==` does type conversion, `===` does not. `==` will ignore the type of a variable and check if the values are equal, but `===` will check to see if the type and value of both operands are equal. 
17) 

